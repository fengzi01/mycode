# cthreadpool
## 借鉴
[非常精简的Linux线程池实现（一）——使用互斥锁和条件变量](http://blog.csdn.net/kxcfzyk/article/details/31719687)
## 总结
线程池是一个非典型的生产者消费者模型，主线程产生任务，放到线程池中，线程池的工作线程消费任务。
- 这里利用队列和互斥锁来保证多线程访问任务同步问题，用队列来充当模型中的缓冲区，但是这个缓冲区可以无限制添加。
- 利用pthread线程条件量来充当模型中的信号量（可读）。
- 这里消费者不需要通知生产者的信号量（可写）。
- 消费者收到可读消息之后，还要做一次判断来识别是否真的可读。

```
read = 0
mutex = 1

// 生成者
while(task_num > 0) {
  P(mutex)
  add_task_into_queue
  V(mutex)
  V(read)
}

// 消费者
while(true) {
  P(read)
  P(mutex)
  dequeue
  V(mutex)
}
```
## 下一步计划
1. 线程任务执行完之后，通知主线程。(生产者消费者模型里，消费者通知生产者)。
2. 线程池销毁时会强制终止所有处于撤销点（cacellation points）的工作线程，如果工作线程正在任务函数中没返回而且任务函数中有非手动创建的撤销点，那么任务函数就会在跑到撤销点时戛然而止，这可能导致意外结果。
